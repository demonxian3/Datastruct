# Datastruct<hr>

#### The code for learning data-struct,Using the C language to programe it.   
#### The data-struct contains the following   

#### 开始旅行时间: 2017-09-08   
#### 初步完成时间: 2018-02-11	    

#### 为什么学习算法？    
本次学习数据结构与算法一共花费了６个月的时长，啃算法就像是啃石头一样难，花费了那么长时间    
学习的途中好几次放弃了重新开始，也因为杂七杂八的事情拖拖拉拉一点一点的完成，以至于花费了     
半年的时间．最初学习编程时听表哥说的一句话让我印象深刻：会编程的人很多，会用算法编写程序的   
人却很少，算法可以明显提高程序的执行效率，从那时为就明白了编程学习数据结构和算法的重要性   
于是开始了学习算法之旅，因为Ｃ语言的struct又可以自定义数据结构，所以最初决定了用Ｃ语言作为武器

学习思路基本就是: 
1. 了解算法原理 
2. 用c语言实现算法 
3. 执行测试 
4. 分析算法时间复杂度　

#### 学了这些算法有没有用?
六个月的学习时间内，有几个简单的算法被运用到了平时的小项目中，对于高级复杂结构或者过于简单
的队列和堆栈，基本上没用到，或在直接调用现成的库来实现，并没有运用上，因为自己写一方面耗时
间，另一方面就是写出的太稚嫩，不够耐用,另外如今在人工智能，大数据分析，区块链领域，对算法的
这一块更加依赖，因此若接触这些领域，算法的学习更是避免不了．

#### 如果一直用不到算法怎么办？
学习Ｂ树算法的时候，虽然明白了原理，花了三天时间的思考，却一直实现不出来，感觉就像是在思考　　　
围棋后六步怎么走一样难．最重要的是前三个月学习到的那些算法，因为在现实编程中用不到或在说来   
不及用，都是直接调用库来实现，导致现在都忘光了说学的东西，这是一件非常痛苦的事情．所以如果   
学习算法时已经很努力了但仍然感到很吃力，那么简单的过一遍经典算法就可以了，虽然这么说很不负   
责任，但如果折腾了大半天的东西，又不知道如何去用他，到头来忘的一干二镜又何苦呢？所以对于算   
法的学习我认为是有必要的，但是又没必要深入的了解，简单的把经典算法和结构过一遍就可以了当你   
用到的时候再去深入了解．    

###  任务清单:

* 线性表
	* 顺序表
	* 单链表
	* 循环链表
	* 双向链表
	* 静态链表
* 栈
	* 顺序栈
	* 链式栈
	* 应用
* 队列
	* 顺序队列
	* 链式队列
	* 应用
* 递归
	* 斐波那契数列(递归)
	* 斐波那契数列(迭代)
	* 最大公约数
	* 汉诺塔
	* 全排列枚举
	
* 字符串
	* KMP算法
	* 简单匹配法
	* 双向匹配法
* 矩阵
	* 对角矩阵
	* 三角矩阵
	* 对称矩阵
	* 稀疏矩阵
		* 三元组表
			* 简单转置
			* 快速转置
		* 十字链表
* 广义表
* 树
	* 树的存储结构
		* 双亲表示法
		* 孩子表示法
		* 双亲孩子表示法
		* 孩子兄弟表示法
	* 二叉树
		* 遍历
			* 先序遍历
			* 中序遍历
			* 后序遍历
			* 层次遍历
			* 应用：二叉树深度算法
		* 线索
			* 中序线索二叉树
			* 先序线索二叉树
		* 哈夫曼树
			* 哈夫曼编码器
* 图
	* 图的存储结构
		* 邻接矩阵
		* 邻接表
		* 十字链表
		* 邻接多重链表
	* 遍历
		* 深度优先
		* 广度优先
	*　最小生成树
		* Prim算法
		* Kruskal算法
	* 最短路径
		* Floyd算法
		* Dijkstra算法
	* 关键路径
	* 拓扑排序
* 查找
	* 顺序表查找
		* 顺序查找
		* 折半查找
		* 分块查找
	* 树表查找
		* 二叉排序树
		* 平衡二叉树
		* B-树查找（未完成）
	* 哈希表查找
* 排序
	* 插入排序
		* 直接插入排序
		* 折半插入排序
		* 希尔排序
	* 选择排序
		* 直接选择排序
		* 堆排序
	* 交换排序
		* 交换排序
		* 快速排序
	

*  ├── array
*  ├── generalizedlist
*  ├── graph
*  ├── liner
*  ├── matrix
*  ├── queue
*  ├── README.md
*  ├── recursion
*  ├── search
*  ├── sort
*  ├── stack
*  ├── string
*  └── tree

